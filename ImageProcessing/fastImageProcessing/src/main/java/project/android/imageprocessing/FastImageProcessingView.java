package project.android.imageprocessing;import android.content.Context;import android.graphics.Bitmap;import android.graphics.Canvas;import android.opengl.GLSurfaceView;import android.util.AttributeSet;import java.nio.IntBuffer;import javax.microedition.khronos.opengles.GL10;/** * Fast image processing view extension of GLSurfaceView.  This class is required for all fast image processing * activities that use this framework.  With the help of the {@link FastImageProcessingPipeline}, this class provides * the OpenGL context required for image processing.  Set of the framework is as follows: * <p> * Add FastImageProcessingView to activity layout. <p> * Add FastImageProcessingPipeline to FastImageProcessingView <p> * Create a input point and attach filter chains to the input and attach endpoints to the filter chains using addTarget. <p> * <code>	image = new ImageResourceInput(view, this, R.drawable.picture); <p> *			filter = new GreyScaleFilter(); <p> *			screen = new ScreenEndpoint(pipeline); <p> *			image.addTarget(filter); <p> *			filter.addTarget(screen); <p> * </code><p> * Pass the input point into the FastImageProcessingPipeline as the root renderer and start the pipeline. <p> * <code>			pipeline.addRootRenderer(image); <p>		pipeline.startRendering(); <p> * </code><p> * @author Chris Batt */public class FastImageProcessingView extends GLSurfaceView {		/**	 * Creates a new view which can be used for fast image processing.	 * @param context The activity context that this view belongs to.	 */	public FastImageProcessingView(Context context) {		this(context, null);			setDebugFlags(GLSurfaceView.DEBUG_CHECK_GL_ERROR | GLSurfaceView.DEBUG_LOG_GL_CALLS);        setEGLContextClientVersion(2);	}		/**	 * Creates a new view which can be used for fast image processing.	 * @param context The activity context that this view belongs to.	 * @param attr The activity attribute set.	 */	public FastImageProcessingView(Context context, AttributeSet attr) {		super(context, attr);			setDebugFlags(GLSurfaceView.DEBUG_CHECK_GL_ERROR | GLSurfaceView.DEBUG_LOG_GL_CALLS);        setEGLContextClientVersion(2);	}		/**	 * Sets the FastImageProcessingPipeline that will do the rendering for this view.	 * @param pipeline The FastImageProcessingPipeline that will do the rendering for this view.	 */	public void setPipeline(FastImageProcessingPipeline pipeline) {		setRenderer(pipeline);		setRenderMode(RENDERMODE_WHEN_DIRTY);	}	public Bitmap createBitmapFromGLSurface(int x, int y, int w, int h, GL10 gl)			throws OutOfMemoryError {		int bitmapBuffer[] = new int[w * h];		int bitmapSource[] = new int[w * h];		IntBuffer intBuffer = IntBuffer.wrap(bitmapBuffer);		intBuffer.position(0);		try {			gl.glReadPixels(x, y, w, h, GL10.GL_RGBA, GL10.GL_UNSIGNED_BYTE, intBuffer);			int offset1, offset2;			for (int i = 0; i < h; i++) {				offset1 = i * w;				offset2 = (h - i - 1) * w;				for (int j = 0; j < w; j++) {					int texturePixel = bitmapBuffer[offset1 + j];					int blue = (texturePixel >> 16) & 0xff;					int red = (texturePixel << 16) & 0x00ff0000;					int pixel = (texturePixel & 0xff00ff00) | red | blue;					bitmapSource[offset2 + j] = pixel;				}			}		} catch (Exception e) {			e.printStackTrace();			return null;		}		return Bitmap.createBitmap(bitmapSource, w, h, Bitmap.Config.ARGB_8888);	}}